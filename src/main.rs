use std::process::Command;
use std::process::ExitStatus;
use std::time::Duration;
use std::time::Instant;

extern crate clap;
extern crate rand;

use rand::distributions::{Distribution, Uniform};

pub enum SlotTime {
	UserSpecified(Duration),
	AutoGenerated(Duration),
}

// This function is a basic implementation of the generic from the
// `core::cmp::Ord` clamp function, which is unstable.  This code is stable,
// but eventually you might want to change this to the `.clamp` method on=
// ord-y things.
pub fn clamp<T>(value: T, min: T, max: T) -> T
where
	T: core::cmp::PartialOrd,
{
	assert!(min <= max);
	if value < min {
		min
	} else if value > max {
		max
	} else {
		value
	}
}

fn main() {
	let max_n: u32 = 10;

	let matches = clap::App::new(env!("CARGO_PKG_NAME"))
		.about(env!("CARGO_PKG_DESCRIPTION"))
		.version(env!("CARGO_PKG_VERSION"))
		.author(env!("CARGO_PKG_AUTHORS"))
		.setting(clap::AppSettings::AllowExternalSubcommands)
		.get_matches();

	let mut command: Command = match matches.subcommand() {
		(name, Some(matches)) => {
			let mut command = Command::new(name);
			let args: Vec<&str> = matches
				.values_of("")
				.map(|v| v.collect())
				.unwrap_or(Vec::new());

			for arg in args {
				command.arg(arg);
			}

			command
		}
		_ => panic!("no command was given"),
	};

	let mut iterations: u32 = 0;
	let mut slot_time: Option<SlotTime> = None;
	let mut rng = rand::thread_rng();

	loop {
		let start: Instant = Instant::now();
		let status: ExitStatus = command.status().expect("failed to execute process");
		let current_iteration_duration: Duration = start.elapsed();

		iterations += 1;

		match status.code() {
			Some(0) => break,
			Some(_) => {}
			None => {
				eprintln!("Child terminated by signal; breaking");
				break;
			}
		}

		if let Some(SlotTime::AutoGenerated(dur)) = &slot_time {
			let dur: Duration = (*dur * (iterations - 1) + current_iteration_duration) / iterations;
			slot_time = Some(SlotTime::AutoGenerated(dur));
		} else if let None = &slot_time {
			slot_time = Some(SlotTime::AutoGenerated(current_iteration_duration));
		}

		let delay: Duration = match &slot_time {
			Some(SlotTime::UserSpecified(dur)) | Some(SlotTime::AutoGenerated(dur)) => {
				let distribution = Uniform::new(0, 2_u32.pow(clamp(iterations + 1, 0, max_n)) - 1);
				let multiplicand: u32 = distribution.sample(&mut rng);

				*dur * multiplicand
			}
			None => Duration::new(0, 0),
		};

		std::thread::sleep(delay);
	}
}
