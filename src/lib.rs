#[cfg(not(feature = "new-error"))]
use core::{
	fmt::{self, Debug, Display, Formatter},
	result,
	time::Duration,
};

#[cfg(feature = "new-error")]
use core::{fmt::Debug, result, time::Duration};

pub enum SlotTime {
	UserSpecified(Duration),
	AutoGenerated(Duration),
}

#[cfg(not(feature = "new-error"))]
#[derive(PartialEq)]
#[non_exhaustive]
#[deprecated = "this implementation will be replaced with a more generic error implementation"]
pub enum Error {
	NoCommandGiven,
	ChildProcessTerminatedWithSignal,
	InvalidMaxValue(String),
}

#[cfg(feature = "new-error")]
#[derive(thiserror::Error, Debug)]
pub enum Error {
	#[error("no command given")]
	NoCommandGiven,
	#[error("child process terminated with signal")]
	ChildProcessTerminatedWithSignal,
	#[error("invalid max argument value: {0}")]
	InvalidMaxValue(String),
}

#[cfg(not(feature = "new-error"))]
#[allow(deprecated)]
impl Debug for Error {
	fn fmt(&self, f: &mut Formatter) -> result::Result<(), fmt::Error> {
		let message: String = match self {
			Self::NoCommandGiven => "no command given".to_string(),
			Self::ChildProcessTerminatedWithSignal => "child process terminated with signal".to_string(),
			Self::InvalidMaxValue(e) => format!("invalid max value: {}", e),
		};

		write!(f, "{}", message)
	}
}

#[cfg(not(feature = "new-error"))]
#[allow(deprecated)]
impl Display for Error {
	fn fmt(&self, f: &mut Formatter) -> result::Result<(), fmt::Error> {
		Debug::fmt(self, f)
	}
}

#[cfg(not(feature = "new-error"))]
#[allow(deprecated)]
impl std::error::Error for Error {}

#[allow(deprecated)]
pub type Result<T> = result::Result<T, Error>;

#[cfg(feature = "new-error")]
pub type ExecutionResult = anyhow::Result<()>;

#[cfg(not(feature = "new-error"))]
pub type ExecutionResult = Result<()>;

#[cfg(test)]
mod tests {}

pub mod backoff;
