use core::{
	fmt::{self, Debug, Display, Formatter},
	result,
	time::Duration,
};

pub enum SlotTime {
	UserSpecified(Duration),
	AutoGenerated(Duration),
}

#[derive(PartialEq)]
pub enum Error {
	NoCommandGiven,
	ChildProcessTerminatedWithSignal,
	InvalidMaxValue(String),
}

impl Debug for Error {
	fn fmt(&self, f: &mut Formatter) -> result::Result<(), fmt::Error> {
		let message: String = match self {
			Self::NoCommandGiven => "no command given".to_string(),
			Self::ChildProcessTerminatedWithSignal => "child process terminated with signal".to_string(),
			Self::InvalidMaxValue(e) => format!("invalid max value: {}", e),
		};

		write!(f, "{}", message)
	}
}

impl Display for Error {
	fn fmt(&self, f: &mut Formatter) -> result::Result<(), fmt::Error> {
		Debug::fmt(self, f)
	}
}

impl std::error::Error for Error {}

pub type Result<T> = result::Result<T, Error>;

pub type ExecutionResult = Result<()>;

#[cfg(test)]
mod tests {}
